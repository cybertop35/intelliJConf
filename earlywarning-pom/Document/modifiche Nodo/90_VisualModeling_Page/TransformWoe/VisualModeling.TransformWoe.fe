var formulaName = "[VisualModeling.TransformWoe] ";
DEBUGMESSAGE(formulaName, "START");

var nodeValue = Param1;
var inputs = Param2;
var visualModelingContext = Param3;

var prevVariables = inputs[0]['variables'];
var prevNodeTableName = inputs[0]['nodeTableName'];

var workspaceId = visualModelingContext['workspaceId'];
var analysisUnitId = visualModelingContext['analysisUnitId'];
var modelId = visualModelingContext['modelId'];
var sessionId = visualModelingContext['sessionId'];

var nodeInfo;
if (nodeValue == null) {
	var result = LIB_VMCommons.runEmptyNode("TRFWOE", inputs);
	DEBUGMESSAGE(formulaName, "NODE VALUE NULL");
	DEBUGMESSAGE(formulaName, "END");
    return result;
}

var nodeName = nodeValue['nodeName'];
var nodeTableName = nodeValue['nodeTableName'];
var nodeStatus = LIB_VMCommons.getNodeStatus(nodeName, sessionId, modelId);
var updated = nodeStatus['updated'];
var variables = nodeStatus['variables'];
DEBUGMESSAGE(formulaName + ' updated : ', updated);

if (updated == false){
    # only if not yet created
    if (nodeValue['saved'] == NULL or nodeValue['saved'] == false) {
        LIB_VMCommons.insertSafeNodeTmpInfo(nodeName, nodeTableName, sessionId, modelId);
    }
    var predictiveDatasourceName = Properties_Predictive[ID="PREDICTIVE_PROPERTIES"].PredictiveDatasourceName;
    LIB_DB.DropTableIfExists(nodeTableName, predictiveDatasourceName);

    variables = CLONE(prevVariables);

	var thresholds = nodeValue['thresholds'];
		DEBUGMESSAGE(formulaName + 'thresholds=', thresholds);
	var dataVar;
	var newVariables = {};
	var continuousValuesTMP = {};
	var continuousValues = [];
	var thresholdConf;
	var statement;
	VAR min;
	VAR max;
	var EqualsMin = null ;
	var EqualsMax = null ;
	var OperatorMin = '>';
	var OperatorMax = '<';
	var VAL_CATEGORICAL = null;
	var val_flag = null ;	

	

	for(var i=0; i<size(variables); i=i+1){ 
		
		statement = statement +  variables[i]['columnName'];
		statement = statement + ",";
	
		IF(thresholds <> null) {
			FOREACHKEY(thresholds as key){
				if (variables[i]['id'] == key) {
					dataVar = [];				
					PUT(dataVar, 'id', 			variables[i]['id'] + "_WOE");
					PUT(dataVar, 'columnName', 	variables[i]['columnName'] + "_WOE");
					PUT(dataVar, 'columnLabel',	variables[i]['columnLabel'] + " New (Woe)");
					PUT(dataVar, 'variableType', 	'CONTINUOUS');
					PUT(dataVar, 'dataType', 		'REAL');
					PUT(dataVar, 'isHiddenColumn',	false);
					PUT(dataVar, 'isKeyColumn', 	false);
					PUT(dataVar, 'isTargetColumn', false);
					PUT(dataVar, 'isSegment', 		false);
					
					thresholdConf = thresholds[key];
					continuousValuesTMP = {};
					continuousValues = [];
					
					
					
					IF(variables[i]['variableType'] ==  'CONTINUOUS'){
						
						
						statement = statement + " CASE ";					
						foreach( thresholdConf as conf ){
						
						DEBUGMESSAGE('****************** CONF', conf) ;
						
						 EqualsMin = conf["EqualsMin"];
						 EqualsMax = conf["EqualsMax"];

						DEBUGMESSAGE('*******************EqualsMin = ',EqualsMin);
						DEBUGMESSAGE('*******************EqualsMax = ',EqualsMax);
						if (EqualsMin == TRUE) { OperatorMin = '>=' ; } ELSE { OperatorMin = '>' ; }
						if (EqualsMax == TRUE) { OperatorMax = '<=' ; } ELSE { OperatorMax = '<' ; }
						
							statement = statement + " WHEN " + variables[i]['columnName'] + OperatorMin +conf["from"] +" and "+ variables[i]['columnName'] + OperatorMax +conf["to"]+ " THEN "+conf["score"];
							addelement(continuousValuesTMP,NUM(conf["score"]));
							
							DEBUGMESSAGE('*******************QUERY',statement);
						}
						statement = statement +" ELSE NULL";
						statement = statement + " END AS " + variables[i]['columnName'] + "_WOE";		

					}

					ELSE IF(variables[i]['variableType'] == 'CATEGORICAL'){
						statement = statement + " CASE ";
						foreach( thresholdConf as conf ){
						
						val_flag = conf[0]["label"];
						
						if (val_flag == 'TRUE') { VAL_CATEGORICAL = '0' ; } else if (val_flag == 'TRUE') { VAL_CATEGORICAL = '1' ; } ELSE {VAL_CATEGORICAL = val_flag ; }
						
							statement = statement + " WHEN " + variables[i]['columnName'] + " = '" + VAL_CATEGORICAL +"' THEN "+conf[1]["inputValue"];
							addelement(continuousValuesTMP,(conf[1]["inputValue"]));
						}			
						statement = statement + " END AS " + variables[i]['columnName'] + "_WOE";					
					}
					statement = statement + ",";
						

					min = MIN(continuousValuesTMP);
					max = MAX(continuousValuesTMP);
					if(min == max )
						max = max +1 ;
						
					DEBUGMESSAGE(key+" = MIN: "+min+" MAX: "+max);		
					
					continuousValues = ['min':min,'max':max];
					PUT(dataVar, 'continuousValues', continuousValues);
					
					ADDELEMENT(newVariables, dataVar);
					
			}		
		}
	}
	
	variables = CONCAT(variables, newVariables);
	statement = SUBSTRING(statement,0,LENGTH(statement) - 1);
	
		
    # create result table
    var query = "CREATE TABLE " + nodeTableName + " AS ( SELECT  " + statement + "  FROM " + prevNodeTableName +" t ) WITH DATA PRIMARY INDEX(SNDG)";
	DEBUGMESSAGE(formulaName + 'query=', query);
	SQLEXECUTE(query, predictiveDatasourceName, null, {});
	DEBUGMESSAGE(formulaName + 'query=OK');
    
	LIB_VMCommons.setNodeStatus(nodeName, ['updated': true, 'variables': variables], sessionId, modelId);
}

# creating output result
var result = [
    'nodeName'      : nodeName,
    'nodeTableName' : nodeTableName,
    'variables'     : variables
];

DEBUGMESSAGE(formulaName, "END");
return result;
