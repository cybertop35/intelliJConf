var formulaName = "[VisualModeling.MissingManagement] ";
DEBUGMESSAGE(formulaName, "START");

var nodeValue = Param1;
var inputs = Param2;
var visualModelingContext = Param3;
DEBUGMESSAGE(formulaName + 'nodeValue=', nodeValue);

var prevVariables = inputs[0]['variables'];
var prevNodeTableName = inputs[0]['nodeTableName'];

var workspaceId = visualModelingContext['workspaceId'];
var analysisUnitId = visualModelingContext['analysisUnitId'];
var modelId = visualModelingContext['modelId'];
var sessionId = visualModelingContext['sessionId'];
var sparkGem = inputs[0]['sparkGem'];

if(IS_EMPTY(nodeValue)) {
	var result = LIB_VMCommons.runEmptyNode("MSMNG", inputs);
	if(VisualModeling.isConnectedToImpala()){
            result['sparkGem'] = sparkGem;
    }
	DEBUGMESSAGE(formulaName, "NODE VALUE NULL");
	DEBUGMESSAGE(formulaName, "END");
    return result;
}

var nodeName = nodeValue['nodeName'];
var nodeTableName = nodeValue['nodeTableName'];
var nodeStatus = LIB_VMCommons.getNodeStatus(nodeName, sessionId, modelId);
var updated = nodeStatus['updated'];
var variables = nodeStatus['variables'];
DEBUGMESSAGE(formulaName + ' updated : ', updated);
var remediations = nodeValue['remediations'];

if(updated == FALSE){
    # only if not yet created
    if(nodeValue['saved'] == NULL OR nodeValue['saved'] == FALSE) {
        LIB_VMCommons.insertSafeNodeTmpInfo(nodeName, nodeTableName, sessionId, modelId);
    }

    var predictiveDatasourceName = Properties_Predictive[ID="PREDICTIVE_PROPERTIES"].PredictiveDatasourceName;
    LIB_DB.DropTableIfExists(nodeTableName, predictiveDatasourceName);

    # get remediations
    variables = CLONE(prevVariables);

    var variablesInfo;
    if(VisualModeling.isConnectedToImpala()){
        var p = LIB_VMCommons.getVariablesInfoSpark(nodeValue, prevNodeTableName, variables, visualModelingContext['sparkSession']['url']);
        variablesInfo = p[0];
    }else{
        variablesInfo = LIB_VMCommons.getVariablesInfo(prevNodeTableName, variables);
    }

    var selectSql;
    var whereSql;
    var statement;
    var dataVar;
    var varInfo;
    var remediationFieldMetadata;
    var newVariables = {};
    var newField;
    var variableInfo;
    for(var i=0; i<size(variables); i=i+1) {
        statement = NULL;
        varInfo = [];
        variableInfo = [];
        foreach (remediations as remediation) {
            if(variables[i]['id'] == remediation['id']) {
                varInfo = variablesInfo[variables[i]['id']];
                newField = remediation['newField'];

                variableInfo = [
                    'columnName' : variables[i]['columnName'],
                    'dataType' : variables[i]['dataType'],
                    'remediation' : remediation['remediation'],
                    'mean' : varInfo['AVG'],
                    'median' : varInfo['MEDIAN'],
                    'moda' : varInfo['MODA'],
                    'specificValue' : remediation['specificValue']
                ];
                statement = MissingManagement.getRemediationsStatements(variableInfo);
                break;
            }
        }
        if(selectSql <> NULL) {
            selectSql = selectSql + ", ";
        }
        if(statement <> NULL) {
            remediationFieldMetadata = MissingManagement.getRemediationFieldMetadata(variableInfo);
            if(newField) {
                selectSql = selectSql + variables[i]['columnName'] + ",";
                selectSql = selectSql + statement + " as " + variables[i]['columnName'] + "_MM";

                ADDELEMENT(newVariables, MissingManagement.getNewField(variables[i], remediationFieldMetadata));
            } else {
                selectSql = selectSql + statement + " as " + variables[i]['columnName'];
                variables[i]['columnLabel'] = variables[i]['columnLabel'] + "*";

                variables[i] = MERGE({variables[i], LIB_VMCommons.updateFieldMetadataWithExtensionOnly(variables[i], remediationFieldMetadata)});
            }
        } else {
            selectSql = selectSql + variables[i]['columnName'];
        }
    }

    if(VisualModeling.isConnectedToImpala()){

         SPARKENGINE([
             'sourceCode' :'
             {
             //Interactive
                val previousDataFrame = visualModelingSparkContext.get(prevNodeTableName)

                val missManag = new MissingManagementSpark(previousDataFrame)
                val newDataFrame = missManag.run(variables, remediations)

                visualModelingSparkContext.put(nodeTableName, newDataFrame.coalesce(1).cache())
             }
             ',
             'inputs' : [
                'prevNodeTableName' : prevNodeTableName,
                'nodeTableName' : nodeTableName,
                'variables' : variables ,
                'remediations' : remediations
             ],
             'uri' : visualModelingContext['sparkSession']['url']]);

             variables = CONCAT(variables, newVariables);

    } else{
        # create result table
        variables = CONCAT(variables, newVariables);

        var sqlSelect = " SELECT " + selectSql + " FROM " + prevNodeTableName;
        if(whereSql <> null) {
            sqlSelect = sqlSelect + " WHERE " + whereSql;
        }

        var query = LIB_DB.createTableAs(nodeTableName,sqlSelect,predictiveDatasourceName);
        DEBUGMESSAGE(formulaName + 'query=', query);
        SQLEXECUTE(query, predictiveDatasourceName, NULL, {});
    }

    LIB_VMCommons.setNodeStatus(nodeName, ['updated': true, 'variables': variables], sessionId, modelId);
}

var sparkOut = [];
if(VisualModeling.isConnectedToImpala()){
     sparkOut = SPARKENGINE([
      'sourceCode' :'
      {
         // Spark code generation for batch
         val previousDataFrame = visualModelingSparkContext.get(prevNodeTableName)

         val missManag = new MissingManagementSpark(previousDataFrame)
         val ( varInfoScalaCode, varRemediationScalaCode ) = missManag.variableToScalaCode(variables, remediations)

         s"val $nodeTableName = new MissingManagementSpark($prevNodeTableName).runGem($varInfoScalaCode, $varRemediationScalaCode)\n"
       }
       ',
       'inputs' : [
          'prevNodeTableName' : prevNodeTableName,
          'nodeTableName' : nodeTableName,
          'variables' : variables ,
          'remediations' : remediations
       ],
       'uri' : visualModelingContext['sparkSession']['url']]);
 }

# creating output result
var result = [
    'nodeName'      : nodeName,
    'nodeTableName' : nodeTableName,
    'variables'     : variables,
    'sparkGem'      : sparkGem + "
    /*Missing Management*/
    " + sparkOut["outputs"] +"
    "
];

DEBUGMESSAGE(formulaName, "END");
return result;