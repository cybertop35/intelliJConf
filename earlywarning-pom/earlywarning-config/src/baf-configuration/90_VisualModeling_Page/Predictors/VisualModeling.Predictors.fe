var formulaName = "[VisualModeling.Predictors] ";
DEBUGMESSAGE(formulaName, "START");

var nodeValue = Param1;
var inputs = Param2;
var visualModelingContext = Param3;

var prevVariables = inputs[0]['variables'];
var prevNodeTableName = inputs[0]['nodeTableName'];

var workspaceId = visualModelingContext['workspaceId'];
var analysisUnitId = visualModelingContext['analysisUnitId'];
var modelId = visualModelingContext['modelId'];
var sessionId = visualModelingContext['sessionId'];
var sparkGem = inputs[0]['sparkGem'];

var predictorsSourceCode;

var result;

if (nodeValue == null) {
	result = LIB_VMCommons.runEmptyNode("PRDTS", inputs);
    if(VisualModeling.isConnectedToImpala()){
       	result['sparkGem'] = sparkGem;
    }

	DEBUGMESSAGE(formulaName, "NODE VALUE NULL");
	DEBUGMESSAGE(formulaName, "END");
    return result;
}

var nodeName = nodeValue['nodeName'];
var nodeTableName = nodeValue['nodeTableName'];
var nodeStatus = LIB_VMCommons.getNodeStatus(nodeName, sessionId, modelId);
var updated = nodeStatus['updated'];
var variables = nodeStatus['variables'];
DEBUGMESSAGE(formulaName + ' updated : ', updated);

if (updated == false){
    # only if not yet created
    if (nodeValue['saved'] == NULL OR nodeValue['saved'] == FALSE) {
        LIB_VMCommons.insertSafeNodeTmpInfo(nodeName, nodeTableName, sessionId, modelId);
    }

    var varId;
    var varLabel;
    var id;
    var label;
    var active;
    var varType;
    variables = {};

    foreach (prevVariables as prevVar) {
        varId = prevVar['id'];
        varLabel = prevVar['columnLabel'];
        varType = prevVar['variableType'];
        if (nodeValue['predictors'][varId] <> null) {
            active = nodeValue['predictors'][varId]['active'];
            IF(active == TRUE){
                ADDELEMENT(variables, prevVar);
            }
        } else {
            ADDELEMENT(variables, prevVar);
        }
    }

    var predictiveDatasourceName = Properties_Predictive[ID="PREDICTIVE_PROPERTIES"].PredictiveDatasourceName;

    if(VisualModeling.isConnectedToImpala()){
        SPARKENGINE([
            'sourceCode' :'
                val visualModelingColumns = getLowerCaseColumnNamesFromListOfMap(variables)
                val previousDataFrame = visualModelingSparkContext.get(prevNodeTableName)
                val filtered = new PredictorsSpark(previousDataFrame).run(visualModelingColumns)
                visualModelingSparkContext.put(nodeTableName, filtered.coalesce(1).cache())
            ',
            'inputs' : ['nodeTableName': nodeTableName, 'prevNodeTableName' : prevNodeTableName, 'variables' : variables],
            'uri' : visualModelingContext['sparkSession']['url']]);
    } else{
        LIB_DB.DropTableIfExists(nodeTableName, predictiveDatasourceName);

        VAR selectClause;
        foreach (variables as variable) {
            if (selectClause <> NULL) {
                selectClause = selectClause + ",";
            }
            selectClause = selectClause + variable['columnName'];
        }
        VAR query = LIB_DB.createTableAs(nodeTableName, "SELECT " + selectClause + " FROM " + prevNodeTableName, predictiveDatasourceName);
        DEBUGMESSAGE(formulaName + ' VM.query : ', query);
        SQLEXECUTE(query, predictiveDatasourceName, null, {});
    }
    LIB_VMCommons.setNodeStatus(nodeName, ['updated': true, 'variables': variables], sessionId, modelId);
}

var columnList = {};
foreach (variables as variable) {
    ADDELEMENT(columnList, variable['columnName']);
}
columnList = VisualModeling.listToString(columnList);

result = [
    'nodeName'      : nodeName,
    'nodeTableName' : nodeTableName,
    'variables'     : variables
];

if(VisualModeling.isConnectedToImpala()){
    result['sparkGem'] = sparkGem + "
    /* Predictors */
    val " + nodeTableName + " = new PredictorsSpark(" + prevNodeTableName + ").run(List(" + columnList + "));
";
}

DEBUGMESSAGE(formulaName, "END");
return result;