var formulaName = "[VisualModeling.TransformWoe] ";
DEBUGMESSAGE(formulaName, "START");

var nodeValue = Param1;
var inputs = Param2;
var visualModelingContext = Param3;

var prevVariables = inputs[0]['variables'];
var prevNodeTableName = inputs[0]['nodeTableName'];

var workspaceId = visualModelingContext['workspaceId'];
var analysisUnitId = visualModelingContext['analysisUnitId'];
var modelId = visualModelingContext['modelId'];
var sessionId = visualModelingContext['sessionId'];

var nodeInfo;
if (nodeValue == null) {
	var result = LIB_VMCommons.runEmptyNode("TRFBN", inputs);
	DEBUGMESSAGE(formulaName, "NODE VALUE NULL");
	DEBUGMESSAGE(formulaName, "END");
    return result;
}

var nodeName = nodeValue['nodeName'];
var nodeTableName = nodeValue['nodeTableName'];
var updated = LIB_VMCommons.getUpdatedStatus(nodeName, sessionId, modelId);
DEBUGMESSAGE(formulaName + 'updated=', updated);

var variables = nodeValue['variables'];

if (updated == false){
    # only if not yet created
    if (nodeValue['saved'] == NULL or nodeValue['saved'] == false) {
        LIB_VMCommons.insertSafeNodeTmpInfo(nodeName, nodeTableName, sessionId, modelId);
    }
    var predictiveDatasourceName = Properties_Predictive[ID="PREDICTIVE_PROPERTIES"].PredictiveDatasourceName;
    LIB_DB.DropTableIfExists(nodeTableName, predictiveDatasourceName);

    # get remediations
    variables = CLONE(prevVariables);
    var remediations = nodeValue['remediations'];
    var variablesInfo = LIB_VMCommons.getVariablesInfo(prevNodeTableName, variables);
    var selectSql;
    var whereSql;
    var statement;
    var rem;
    var dataVar;
    var varInfo;
    var categoricalValues;
    var continuousValues;
    var newVariables = {};
    var cat;
    var positiveCategoricalValues;
    var negativeCategoricalValues;
    for(var i=0; i<size(variables); i=i+1){
        statement = NULL;
        rem = [];
        varInfo = [];
        categoricalValues = {};
        continuousValues = [];
        foreach (remediations as remediation) {
            if (variables[i]['id'] == remediation['id']) {
                varInfo = variablesInfo[variables[i]['id']];
                PUT(rem, 'id', variables[i]['id']);
                PUT(rem, 'columnName', variables[i]['columnName']);
                PUT(rem, 'remediation', remediation['remediation']);
                PUT(rem, 'numberInput', remediation['numberInput']);
                PUT(rem, 'newField', remediation['newField']);
                PUT(rem, 'min', varInfo['MIN']);
                PUT(rem, 'max', varInfo['MAX']);
                PUT(rem, 'mean', varInfo['AVG']);
                PUT(rem, 'stdDev', varInfo['STD_DEV']);

                if (remediation['remediation']=="BINNING_QUANTILES") {
                    statement = TransformBin.getBinningQuantiles(rem);
                    for (cat=1;cat<=remediation['numberInput'];cat=cat+1) {
                        ADDELEMENT(categoricalValues, cat);
                    }
                }

                if (remediation['remediation']=="BINNING_FIXEDWIDTH") {
                    statement = TransformBin.getBinningFixedWidth(rem);
                    for (cat=1;cat<=remediation['numberInput'];cat=cat+1) {
                        ADDELEMENT(categoricalValues, cat);
                    }
                }

                if (remediation['remediation']=="BINNING_STDDEVS") {
                    statement = TransformBin.getBinningStandardDevs(rem);
                    positiveCategoricalValues = {};
                    negativeCategoricalValues = {};
                    for (cat=1; cat<remediation['numberInput']+2; cat=cat+1) {
                        ADDELEMENT(positiveCategoricalValues, cat);
                        ADDELEMENT(negativeCategoricalValues, -1*cat);
                    }
                    categoricalValues = CONCAT(REVERSE(negativeCategoricalValues), positiveCategoricalValues);
                }

                if (remediation['remediation']=="TRANSFORMATION_EXP") {
                    statement = TransformBin.getTransformationExp(rem);
                    continuousValues = ['min': EXP(variables[i]['continuousValues']['min']), 'max': EXP(variables[i]['continuousValues']['max'])];
                }

                if (remediation['remediation']=="TRANSFORMATION_LOG") {
                    statement = TransformBin.getTransformationLog(rem);
                    continuousValues = ['min': 0, 'max': LOG(1 + variables[i]['continuousValues']['max'] - variables[i]['continuousValues']['min'])/LOG(remediation['numberInput'])];
                }

                if (remediation['remediation']=="TRANSFORMATION_POWER") {
                    statement = TransformBin.getTransformationPower(rem);
                    continuousValues = ['min': variables[i]['continuousValues']['min']^remediation['numberInput'], 'max': variables[i]['continuousValues']['max']^remediation['numberInput']];
                }
                break;
            }
        }
        if (selectSql <> NULL) {
            selectSql = selectSql + ", ";
        }
        if (statement <> NULL) {
            if (rem['newField']) {
                selectSql = selectSql + variables[i]['columnName'] + ",";
                selectSql = selectSql + statement['select'] + " as " + variables[i]['columnName'] + "_TB";

                dataVar = [];
                PUT(dataVar, 'id', variables[i]['id'] + "_TB");
                PUT(dataVar, 'columnName', variables[i]['columnName'] + "_TB");
                PUT(dataVar, 'columnLabel', variables[i]['columnLabel'] + " New (TB)");
                if (ISLIKE(rem['remediation'], "BINNING%")) {
                    PUT(dataVar, 'variableType', 'ORDINAL');
                    PUT(dataVar, 'dataType', 'INTEGER');
                } else {
                    PUT(dataVar, 'variableType', 'CONTINUOUS');
                    PUT(dataVar, 'dataType', 'REAL');
                }
                PUT(dataVar, 'isHiddenColumn', false);
                PUT(dataVar, 'isKeyColumn', false);
                PUT(dataVar, 'isTargetColumn', false);
                PUT(dataVar, 'isSegment', false);
                PUT(dataVar, 'isPartitioningColumn', false);
                PUT(dataVar, 'isEmptyContinuousVariable', false);
                PUT(dataVar, 'categoricalValues', categoricalValues);
                PUT(dataVar, 'continuousValues', continuousValues);
                ADDELEMENT(newVariables, dataVar);
            } else {
                selectSql = selectSql + statement['select'] + " as " + variables[i]['columnName'] + "_TB";
                PUT(variables[i], 'columnName', variables[i]['columnName'] + "_TB");
                PUT(variables[i], 'columnLabel', variables[i]['columnLabel'] + "*");
                if (ISLIKE(rem['remediation'], "BINNING%")) {
                    PUT(variables[i], 'variableType', 'ORDINAL');
                    PUT(variables[i], 'dataType', 'INTEGER');
                }
                PUT(variables[i], 'categoricalValues', categoricalValues);
                PUT(variables[i], 'continuousValues', continuousValues);
            }
        } else {
            selectSql = selectSql + variables[i]['columnName'];
        }
    }
    variables = CONCAT(variables, newVariables);

    # create result table
    var query = "CREATE TABLE " + nodeTableName + " AS SELECT " + selectSql + " FROM " + prevNodeTableName;
    if (whereSql <> null) {
        query = query + " WHERE " + whereSql;
    }
    SQLEXECUTE(query, predictiveDatasourceName, null, {});

    DEBUGMESSAGE(formulaName + 'query=', query);

    LIB_VMCommons.setUpdatedStatus(nodeName, true, sessionId, modelId);
}

# creating output result
var result = [
    'nodeName'      : nodeName,
    'nodeTableName' : nodeTableName,
    'variables'     : variables
];

DEBUGMESSAGE(formulaName, "END");
return result;
