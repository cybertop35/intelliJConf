var formulaName = "[VisualModeling.TransformWoe] ";
DEBUGMESSAGE(formulaName, "START");

var nodeValue = Param1;
var inputs = Param2;
var visualModelingContext = Param3;

var prevVariables = inputs[0]['variables'];
var prevNodeTableName = inputs[0]['nodeTableName'];

var workspaceId = visualModelingContext['workspaceId'];
var analysisUnitId = visualModelingContext['analysisUnitId'];
var modelId = visualModelingContext['modelId'];
var sessionId = visualModelingContext['sessionId'];

var nodeInfo;
if (nodeValue == null) {
	var result = LIB_VMCommons.runEmptyNode("TRFWOE", inputs);
	DEBUGMESSAGE(formulaName, "NODE VALUE NULL");
	DEBUGMESSAGE(formulaName, "END");
    return result;
}

var nodeName = nodeValue['nodeName'];
var nodeTableName = nodeValue['nodeTableName'];
var updated = LIB_VMCommons.getUpdatedStatus(nodeName, sessionId, modelId);
DEBUGMESSAGE(formulaName + 'updated=', updated);

var variables = nodeValue['variables'];

if (updated == false){
    # only if not yet created
    if (nodeValue['saved'] == NULL or nodeValue['saved'] == false) {
        LIB_VMCommons.insertSafeNodeTmpInfo(nodeName, nodeTableName, sessionId, modelId);
    }
    var predictiveDatasourceName = Properties_Predictive[ID="PREDICTIVE_PROPERTIES"].PredictiveDatasourceName;
    LIB_DB.DropTableIfExists(nodeTableName, predictiveDatasourceName);

    variables = CLONE(prevVariables);

	var thresholds = nodeValue['thresholds'];
		DEBUGMESSAGE(formulaName + 'thresholds=', thresholds);
	var dataVar;
	var newVariables = {};
	var continuousValuesTMP = {};
	var continuousValues = [];
	var thresholdConf;
	var statement;
	VAR min;
	VAR max;
	for(var i=0; i<size(variables); i=i+1){ 
		statement = statement +  variables[i]['columnName'];
		statement = statement + ",";

		IF(thresholds <> null) {
			FOREACHKEY(thresholds as key){
				if (variables[i]['id'] == key) {
					dataVar = [];				
					PUT(dataVar, 'id', 			variables[i]['id'] + "_WOE");
					PUT(dataVar, 'columnName', 	variables[i]['columnName'] + "_WOE");
					PUT(dataVar, 'columnLabel',	variables[i]['columnLabel'] + " New (Woe)");
					PUT(dataVar, 'variableType', 	'CONTINUOUS');
					PUT(dataVar, 'dataType', 		'REAL');
					PUT(dataVar, 'isHiddenColumn',	false);
					PUT(dataVar, 'isKeyColumn', 	false);
					PUT(dataVar, 'isTargetColumn', false);
					PUT(dataVar, 'isSegment', 		false);
					
					thresholdConf = thresholds[key];
					continuousValuesTMP = {};
					continuousValues = [];
					
					IF(variables[i]['variableType'] ==  'CONTINUOUS'){
						
						statement = statement + " CASE ";					
						foreach( thresholdConf as conf ){
							statement = statement + " WHEN " + variables[i]['columnName'] + " > " +conf["from"] +" and "+ variables[i]['columnName'] + " <= " +conf["to"]+ " THEN "+conf["score"];
							addelement(continuousValuesTMP,NUM(conf["score"]));
						}			
						statement = statement + " END AS " + variables[i]['columnName'] + "_WOE";					
					}
					ELSE IF(variables[i]['variableType'] == 'CATEGORICAL'){
						statement = statement + " CASE ";
						foreach( thresholdConf as conf ){
							statement = statement + " WHEN " + variables[i]['columnName'] + " = '" +conf[0]["label"] +"' THEN "+conf[1]["inputValue"];
							addelement(continuousValuesTMP,(conf[1]["inputValue"]));
						}			
						statement = statement + " END AS " + variables[i]['columnName'] + "_WOE";					
					}
					statement = statement + ",";
						

					min = MIN(continuousValuesTMP);
					max = MAX(continuousValuesTMP);

					DEBUGMESSAGE(key+" = MIN: "+min+" MAX: "+max);		
					
					continuousValues = ['min':min,'max':max];
					PUT(dataVar, 'continuousValues', continuousValues);
					
					ADDELEMENT(newVariables, dataVar);
				}	
			}		
		}
	}
	
	variables = CONCAT(variables, newVariables);
	statement = SUBSTRING(statement,0,LENGTH(statement) - 1);
	
	
    # create result table
    var query = "CREATE TABLE " + nodeTableName + " AS SELECT " + statement + "  FROM " + prevNodeTableName;
	SQLEXECUTE(query, predictiveDatasourceName, null, {});

    DEBUGMESSAGE(formulaName + 'query=', query);

    LIB_VMCommons.setUpdatedStatus(nodeName, true, sessionId, modelId);
}

# creating output result
var result = [
    'nodeName'      : nodeName,
    'nodeTableName' : nodeTableName,
    'variables'     : variables
];

DEBUGMESSAGE(formulaName, "END");
return result;
